<!DOCTYPE html>
<html lang="es">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1.0">
<title>Liga de Baloncesto AutomÃ¡tica</title>
<style>
body { font-family: Arial, sans-serif; padding: 20px; }
textarea { width: 100%; height: 100px; margin-bottom: 10px; }
button { margin: 5px; padding: 10px; cursor: pointer; }
h2 { margin-top: 20px; }
ul { list-style: none; padding: 0; }
li { margin: 3px 0; }
.equipo { display: inline-block; width: 45%; vertical-align: top; }
</style>
</head>
<body>

<h1>Liga de Baloncesto AutomÃ¡tica ğŸ€</h1>

<h2>Lista de jugadores (escribe "(invitado)" en el nombre si aplica)</h2>
<textarea id="lista"></textarea><br>
<button onclick="cargarLista()">â• Agregar jugadores</button>
<button onclick="siguientePartido()">â¡ï¸ Siguiente Partido</button>
<button onclick="ganaA()">ğŸ† Gana Equipo A</button>
<button onclick="ganaB()">ğŸ† Gana Equipo B</button>

<h2>Partido #<span id="nPartido">0</span></h2>

<div class="equipo">
  <h3>Equipo A</h3>
  <ul id="equipoA"></ul>
</div>

<div class="equipo">
  <h3>Equipo B</h3>
  <ul id="equipoB"></ul>
</div>

<script>
let colaLiga = [];
let colaInvitados = [];
let campeon = [];
let ultimoEnCancha = new Set();
let modo = 'normal'; // 'normal' o 'retador'
let A = [], B = [];
let nPartido = 0;
let consecutivosA = 0, consecutivosB = 0;
let esperandoRetador = false;

// âœ… Permite agregar jugadores sin perder los anteriores
function cargarLista() {
  const lines = document.getElementById('lista').value
    .split('\n')
    .map(l => l.trim())
    .filter(l => l);

  let nuevos = 0;

  lines.forEach(j => {
    const jugador = j.trim();
    const esInvitado = jugador.toLowerCase().includes('(invitado)');
    if (!colaLiga.includes(jugador) && !colaInvitados.includes(jugador)) {
      if (esInvitado) colaInvitados.push(jugador);
      else colaLiga.push(jugador);
      nuevos++;
    }
  });

  alert(`Se agregaron ${nuevos} nuevos jugadores. Total: ${colaLiga.length + colaInvitados.length}`);
  document.getElementById('lista').value = '';
}

// ğŸ”„ Tomar jugadores sin repetir
function tomar(cola, n, ex = new Set()) {
  const seleccion = [];
  let i = 0;
  while (seleccion.length < n && i < cola.length * 3) {
    const jugador = cola.shift();
    if (!ex.has(jugador)) {
      seleccion.push(jugador);
      ex.add(jugador);
    }
    cola.push(jugador); // regresa al final
    i++;
  }
  return seleccion;
}

// ğŸ® Generar equipos segÃºn la etapa
function generarEquipos() {
  let ex = new Set([...ultimoEnCancha, ...campeon]);

  if (campeon.length === 0) {
    // Primera ronda
    const primeros = tomar(colaLiga, 10, ex);
    A = primeros.slice(0, 5);
    B = primeros.slice(5, 10);
  } 
  else if (modo === 'retador') {
    // Generar 10 nuevos para definir retador
    const nuevos = retador();
    A = nuevos.slice(0, 5);
    B = nuevos.slice(5, 10);
  } 
  else if (modo === 'campeon_vs_retador') {
    // CampeÃ³n vs Retador
    A = campeon;
    B = retadorEquipo;
  }

  ultimoEnCancha = new Set([...A, ...B]);
  mostrarEquipos();
}

function retador() {
  let ex = new Set([...ultimoEnCancha, ...campeon]);
  const L = tomar(colaLiga, 6, ex);
  const I = tomar(colaInvitados, 4, ex);
  const equipo = [...L, ...I];
  return equipo;
}

function mostrarEquipos() {
  document.getElementById('equipoA').innerHTML = A.map(j => "<li>" + j + "</li>").join('');
  document.getElementById('equipoB').innerHTML = B.map(j => "<li>" + j + "</li>").join('');
  document.getElementById('nPartido').textContent = nPartido;
}

function siguientePartido() {
  nPartido++;

  if (modo === 'campeon_vs_retador') {
    modo = 'retador';
  }

  generarEquipos();
}

// ğŸ† Marcar ganador
function ganaA() { procesarGanador('A'); }
function ganaB() { procesarGanador('B'); }

let retadorEquipo = [];

function procesarGanador(ganador) {
  const perdedor = ganador === 'A' ? B : A;
  const equipoGanador = ganador === 'A' ? A : B;

  // Registrar ganador y actualizar consecutivos
  if (equipoGanador.toString() === campeon.toString()) {
    if (ganador === 'A') consecutivosA++;
    else consecutivosB++;
  } else {
    consecutivosA = ganador === 'A' ? 1 : 0;
    consecutivosB = ganador === 'B' ? 1 : 0;
  }

  // Mover perdedores al final de sus colas
  perdedor.forEach(p => {
    if (!colaLiga.includes(p) && !colaInvitados.includes(p)) {
      if (p.toLowerCase().includes('(invitado)')) colaInvitados.push(p);
      else colaLiga.push(p);
    }
  });

  // ğŸ§  LÃ³gica principal
  if (campeon.length === 0 && (consecutivosA >= 2 || consecutivosB >= 2)) {
    // Primer campeÃ³n
    campeon = equipoGanador;
    modo = 'retador';
    alert("ğŸ… Nuevo campeÃ³n establecido!");
  } 
  else if (modo === 'retador' && (consecutivosA >= 2 || consecutivosB >= 2)) {
    // Ganador del grupo de nuevos -> retador
    retadorEquipo = equipoGanador;
    modo = 'campeon_vs_retador';
    consecutivosA = consecutivosB = 0;
    alert("âš”ï¸ Se definiÃ³ un retador. Siguiente partido: CampeÃ³n vs Retador");
  } 
  else if (modo === 'campeon_vs_retador') {
    // Duelo entre campeÃ³n y retador
    if (equipoGanador.toString() === campeon.toString()) {
      alert("ğŸ‘‘ El campeÃ³n defendiÃ³ su tÃ­tulo!");
    } else {
      campeon = equipoGanador;
      alert("ğŸ‘‘ Nuevo campeÃ³n coronado!");
    }
    modo = 'retador';
    consecutivosA = consecutivosB = 0;
  }
}
</script>

</body>
</html>
